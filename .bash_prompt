#
# my simple bash prompt
# inspired by necolas's dotfiles
# https://github.com/necolas/dotfiles/blob/master/shell/bash_prompt
#

# makes the git prompt
# pretty much the same as necolas's
# https://github.com/necolas/dotfiles/blob/master/shell/bash_prompt#L14
prompt_git() {
  local s=""
  local branchName=""

  # check if the current directory is in a git repository
  if [ $(git rev-parse --is-inside-work-tree &>/dev/null; printf "%s" $?) == 0 ]; then

    # check if the current directory is in .git before running git checks
    if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == "false" ]; then

      # ensure index is up to date
      git update-index --really-refresh  -q &>/dev/null

      # check for uncommitted changes in the index
      if ! $(git diff --quiet --ignore-submodules --cached); then
        s="$s+";
      fi

      # check for unstaged changes
      if ! $(git diff-files --quiet --ignore-submodules --); then
        s="$s!";
      fi

      # check for untracked files
      if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        s="$s?";
      fi

      # check for stashed files
      if $(git rev-parse --verify refs/stash &>/dev/null); then
        s="$s$";
      fi

    fi

    # get the short symbolic ref
    # if HEAD isn't a symbolic ref, get the short SHA
    # otherwise, just give up
    branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
                  git rev-parse --short HEAD 2> /dev/null || \
                  printf "(unknown)")"

    [ -n "$s" ] && s="[$s]"

    printf "%s" "$1$branchName$s "
  else
    return
  fi
}

# save history ASAP
export PROMPT_COMMAND="history -a; $PROMPT_COMMAND"

# construct PS1
PS1="$IBlue\w " # current working directory
PS1+="$IGreen\$(prompt_git)" # git details
PS1+="$IWhite\$ " # the $
PS1+="$Color_Off" # reset color
